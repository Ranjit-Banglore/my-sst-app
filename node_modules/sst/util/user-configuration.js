// @ts-nocheck
import * as os from "os";
import * as fs_path from "path";
import * as fs from "fs";
export const PROJECT_CONFIG = "cdk.json";
export const USER_DEFAULTS = "~/.cdk.json";
const CONTEXT_KEY = "context";
const cdkToolkitUrl = await import.meta.resolve("@aws-cdk/toolkit-lib");
const cdkToolkitPath = new URL(cdkToolkitUrl).pathname;
const { ToolkitError } = await import(cdkToolkitPath);
const { Context, PROJECT_CONTEXT } = await import(fs_path.resolve(cdkToolkitPath, "..", "api", "context.js"));
const { Settings } = await import(fs_path.resolve(cdkToolkitPath, "..", "api", "settings.js"));
const { Tags } = await import(fs_path.resolve(cdkToolkitPath, "..", "api", "tags", "index.js"));
export var Command;
(function (Command) {
    Command["LS"] = "ls";
    Command["LIST"] = "list";
    Command["DIFF"] = "diff";
    Command["BOOTSTRAP"] = "bootstrap";
    Command["DEPLOY"] = "deploy";
    Command["DESTROY"] = "destroy";
    Command["SYNTHESIZE"] = "synthesize";
    Command["SYNTH"] = "synth";
    Command["METADATA"] = "metadata";
    Command["INIT"] = "init";
    Command["VERSION"] = "version";
    Command["WATCH"] = "watch";
    Command["GC"] = "gc";
    Command["ROLLBACK"] = "rollback";
    Command["IMPORT"] = "import";
    Command["ACKNOWLEDGE"] = "acknowledge";
    Command["ACK"] = "ack";
    Command["NOTICES"] = "notices";
    Command["MIGRATE"] = "migrate";
    Command["CONTEXT"] = "context";
    Command["DOCS"] = "docs";
    Command["DOC"] = "doc";
    Command["DOCTOR"] = "doctor";
    Command["REFACTOR"] = "refactor";
    Command["DRIFT"] = "drift";
})(Command || (Command = {}));
const BUNDLING_COMMANDS = [
    Command.DEPLOY,
    Command.DIFF,
    Command.SYNTH,
    Command.SYNTHESIZE,
    Command.WATCH,
    Command.IMPORT,
];
/**
 * All sources of settings combined
 */
export class Configuration {
    props;
    settings = new Settings();
    context = new Context();
    defaultConfig = new Settings({
        versionReporting: true,
        assetMetadata: true,
        pathMetadata: true,
        output: "cdk.out",
    });
    commandLineArguments;
    commandLineContext;
    _projectConfig;
    _projectContext;
    loaded = false;
    constructor(props = {}) {
        this.props = props;
        this.commandLineArguments = props.commandLineArguments
            ? commandLineArgumentsToSettings(props.commandLineArguments)
            : new Settings();
        this.commandLineContext = this.commandLineArguments
            .subSettings([CONTEXT_KEY])
            .makeReadOnly();
    }
    get projectConfig() {
        if (!this._projectConfig) {
            throw new ToolkitError("#load has not been called yet!");
        }
        return this._projectConfig;
    }
    get projectContext() {
        if (!this._projectContext) {
            throw new ToolkitError("#load has not been called yet!");
        }
        return this._projectContext;
    }
    /**
     * Load all config
     */
    async load() {
        const userConfig = await loadAndLog(USER_DEFAULTS);
        this._projectConfig = await loadAndLog(PROJECT_CONFIG);
        this._projectContext = await loadAndLog(PROJECT_CONTEXT);
        // @todo cannot currently be disabled by cli users
        const readUserContext = this.props.readUserContext ?? true;
        if (userConfig.get(["build"])) {
            throw new ToolkitError("The `build` key cannot be specified in the user config (~/.cdk.json), specify it in the project config (cdk.json) instead");
        }
        const contextSources = [
            { bag: this.commandLineContext },
            {
                fileName: PROJECT_CONFIG,
                bag: this.projectConfig.subSettings([CONTEXT_KEY]).makeReadOnly(),
            },
            { fileName: PROJECT_CONTEXT, bag: this.projectContext },
        ];
        if (readUserContext) {
            contextSources.push({
                fileName: USER_DEFAULTS,
                bag: userConfig.subSettings([CONTEXT_KEY]).makeReadOnly(),
            });
        }
        this.context = new Context(...contextSources);
        // Build settings from what's left
        this.settings = this.defaultConfig
            .merge(userConfig)
            .merge(this.projectConfig)
            .merge(this.commandLineArguments)
            .makeReadOnly();
        this.loaded = true;
        return this;
    }
    /**
     * Save the project context
     */
    async saveContext() {
        if (!this.loaded) {
            return this;
        } // Avoid overwriting files with nothing
        await this.projectContext.save(PROJECT_CONTEXT);
        return this;
    }
}
async function loadAndLog(fileName) {
    return await settingsFromFile(fileName);
}
async function settingsFromFile(fileName) {
    let settings;
    const expanded = expandHomeDir(fileName);
    if (fs.existsSync(expanded)) {
        const data = JSON.parse(fs.readFileSync(expanded, "utf-8"));
        settings = new Settings(data);
    }
    else {
        settings = new Settings();
    }
    // See https://github.com/aws/aws-cdk/issues/59
    prohibitContextKeys(settings, ["default-account", "default-region"], fileName);
    warnAboutContextKey(settings, "aws:", fileName);
    return settings;
}
function prohibitContextKeys(settings, keys, fileName) {
    const context = settings.get(["context"]);
    if (!context || typeof context !== "object") {
        return;
    }
    for (const key of keys) {
        if (key in context) {
            throw new ToolkitError(`The 'context.${key}' key was found in ${fs_path.resolve(fileName)}, but it is no longer supported. Please remove it.`);
        }
    }
}
function warnAboutContextKey(settings, prefix, fileName) {
    const context = settings.get(["context"]);
    if (!context || typeof context !== "object") {
        return;
    }
    for (const contextKey of Object.keys(context)) {
        if (contextKey.startsWith(prefix)) {
            console.warn(`A reserved context key ('context.${prefix}') key was found in ${fs_path.resolve(fileName)}, it might cause surprising behavior and should be removed.`);
        }
    }
}
function expandHomeDir(x) {
    if (x.startsWith("~")) {
        return fs_path.join(os.homedir(), x.slice(1));
    }
    return x;
}
/**
 * Parse CLI arguments into Settings
 *
 * CLI arguments in must be accessed in the CLI code via
 * `configuration.settings.get(['argName'])` instead of via `args.argName`.
 *
 * The advantage is that they can be configured via `cdk.json` and
 * `$HOME/.cdk.json`. Arguments not listed below and accessed via this object
 * can only be specified on the command line.
 *
 * @param argv - the received CLI arguments.
 * @returns a new Settings object.
 */
export function commandLineArgumentsToSettings(argv) {
    const context = parseStringContextListToObject(argv);
    const tags = parseStringTagsListToObject(expectStringList(argv.tags));
    // Determine bundling stacks
    let bundlingStacks;
    if (BUNDLING_COMMANDS.includes(argv._[0])) {
        // If we deploy, diff, synth or watch a list of stacks exclusively we skip
        // bundling for all other stacks.
        bundlingStacks = argv.exclusively ? argv.STACKS ?? ["**"] : ["**"];
    }
    else {
        // Skip bundling for all stacks
        bundlingStacks = [];
    }
    return new Settings({
        app: argv.app,
        browser: argv.browser,
        build: argv.build,
        caBundlePath: argv.caBundlePath,
        context,
        debug: argv.debug,
        tags,
        language: argv.language,
        pathMetadata: argv.pathMetadata,
        assetMetadata: argv.assetMetadata,
        profile: argv.profile,
        plugin: argv.plugin,
        requireApproval: argv.requireApproval,
        toolkitStackName: argv.toolkitStackName,
        toolkitBucket: {
            bucketName: argv.bootstrapBucketName,
            kmsKeyId: argv.bootstrapKmsKeyId,
        },
        versionReporting: argv.versionReporting,
        staging: argv.staging,
        output: argv.output,
        outputsFile: argv.outputsFile,
        progress: argv.progress,
        proxy: argv.proxy,
        bundlingStacks,
        lookups: argv.lookups,
        rollback: argv.rollback,
        notices: argv.notices,
        assetParallelism: argv["asset-parallelism"],
        assetPrebuild: argv["asset-prebuild"],
        ignoreNoStacks: argv["ignore-no-stacks"],
        hotswap: {
            ecs: {
                minimumHealthyPercent: argv.hotswapEcsMinimumHealthyPercent,
                maximumHealthyPercent: argv.hotswapEcsMaximumHealthyPercent,
                stabilizationTimeoutSeconds: argv.hotswapEcsStabilizationTimeoutSeconds,
            },
        },
        unstable: argv.unstable,
    });
}
function expectStringList(x) {
    if (x === undefined) {
        return undefined;
    }
    if (!Array.isArray(x)) {
        throw new ToolkitError(`Expected array, got '${x}'`);
    }
    const nonStrings = x.filter((e) => typeof e !== "string");
    if (nonStrings.length > 0) {
        throw new ToolkitError(`Expected list of strings, found ${nonStrings}`);
    }
    return x;
}
function parseStringContextListToObject(argv) {
    const context = {};
    for (const assignment of argv.context || []) {
        const parts = assignment.split(/=(.*)/, 2);
        if (parts.length === 2) {
            if (parts[0].match(/^aws:.+/)) {
                throw new ToolkitError(`User-provided context cannot use keys prefixed with 'aws:', but ${parts[0]} was provided.`);
            }
            context[parts[0]] = parts[1];
        }
        else {
            console.warn("Context argument is not an assignment (key=value): %s", assignment);
        }
    }
    return context;
}
/**
 * Parse tags out of arguments
 *
 * Return undefined if no tags were provided, return an empty array if only empty
 * strings were provided
 */
function parseStringTagsListToObject(argTags) {
    if (argTags === undefined) {
        return undefined;
    }
    if (argTags.length === 0) {
        return undefined;
    }
    const nonEmptyTags = argTags.filter((t) => t !== "");
    if (nonEmptyTags.length === 0) {
        return [];
    }
    const tags = [];
    for (const assignment of nonEmptyTags) {
        const parts = assignment.split(/=(.*)/, 2);
        if (parts.length === 2) {
            tags.push({
                Key: parts[0],
                Value: parts[1],
            });
        }
        else {
            console.warn("Tags argument is not an assignment (key=value): %s", assignment);
        }
    }
    return tags.length > 0 ? tags : undefined;
}
